:doctype: book
include::Title.adoc[]


:toc: macro
:figure-caption: Рисунок

toc::[title=Оглавление]

== 1. Цель работы

Изучение принципов инициализации тактовой системы и портов ввода-вывода микроконтроллера STM32, а также реализация простейшего управления внешними устройствами (светодиодом и кнопкой) с использованием прямого доступа к регистрам периферии через C++.

== 2. Описание программы

Программа написана на языке C++ и предназначена для работы на микроконтроллере семейства STM32. Она включает:

- Инициализацию системной тактовой частоты от внутреннего генератора HSI (16 МГц).
- Настройку портов GPIOA и GPIOC.
- Реализацию toggle-переключателя: при нажатии кнопки меняется состояние светодиода.

== 3. Этапы выполнения программы

=== 3.1. Низкоуровневая инициализация (`__low_level_init`)

Выполняется до входа в функцию `main`:

. Включается внутренний RC-генератор HSI (16 МГц) через бит `HSION` в регистре `RCC->CR`.
. Ожидается установка флага готовности `HSIRDY`.
. Системная тактовая частота переключается на HSI через поле `SW` регистра `RCC->CFGR`.
. Проверяется успешное переключение по значению поля `SWS`.
. Включается тактирование модуля `SYSCFG` (хотя он в программе не используется).

=== 3.2. Инициализация в `main`

. Включается тактирование портов **GPIOA** и **GPIOC** через регистр `RCC->AHB1ENR`.
. Настраиваются направления пинов:
  - `PA5` — выход,
  - `PC5`, `PC8`, `PC9` — выходы.
. В цикле `for(;;)` реализуется логика управления.\

==== Код функции void main():

----
int main()
{ 
 
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOA::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::MODER::MODER8::Output::Set() ;
  GPIOC::MODER::MODER9::Output::Set() ;
  uint32_t i = 0;
  uint32_t stage = 0;
  for(;;)
  { 
   std::uint32_t* const gpiocOdrPtr = reinterpret_cast<std::uint32_t*>(0x40020814U);
   std::uint32_t* const gpioaOdrPtr = reinterpret_cast<std::uint32_t*>(0x40020014U);
   std::uint32_t* const gpiocIdrPtr = reinterpret_cast<std::uint32_t*>(0x40020810U);
   auto volatile idrValue= *gpiocIdrPtr;
   bool isButtonPressed = ((idrValue & (1<<13))==0);
   
   *gpiocOdrPtr|= (1<<i);
  switch (stage)
  {
  case 0:
    {
      i=5; 
      break;
    }  
  case 1: 
    {
      i=8; 
      break;
    }  
  case 2: 
    {
      i=9; 
      break;
    }
  case 3: 
    {
      *gpioaOdrPtr |= (1<<5); 
      break;
    }
  case 4: 
    {
      *gpiocOdrPtr &=~ ((1<<5)|(1<<8)|(1<<9)); 
      *gpioaOdrPtr &=~ (1<<5); 
      break;
    }
  }

  return 1;
}
----


=== 3.3. Основной цикл

. Считывается входной регистр порта C (`IDR`) по адресу `0x4002'0810`.
. Проверяется состояние пина **PC13**: если он **заземлён** (0), считается, что кнопка нажата.
. При обнаружении нажатия переключается состояние светодиода на **PC5**:
  - `flag == false` → включить светодиод (`ODR |= (1 << 5)`), установить `flag = true`.
  - `flag == true` → выключить светодиод (`ODR &= ~(1 << 5)`), установить `flag = false`.
. После обработки выполняется программная задержка (~1 млн циклов) для подавления дребезга контактов.

== 4. Используемая периферия

В программе используется следующая периферия:

- Пин PC13 настроен как вход и подключён к кнопке, работающей по схеме «активный ноль» (то есть нажатие кнопки приводит к логическому нулю на пине).
- Пин PC5 настроен как выход и управляет светодиодом, реализуя функцию переключателя (toggle): каждое нажатие кнопки меняет состояние светодиода на противоположное.
- Пины PA5, PC8 и PC9 также настроены как выходы, однако в текущей версии программы они не используются — их инициализация, вероятно, осталась от предыдущей или расширенной версии прошивки.

== 5. Достоинства и недостатки реализации

=== Достоинства

- Чёткая структура: разделение инициализации и основной логики.
- Использование типобезопасных шаблонных интерфейсов для работы с регистрами (например, `RCC::CR::HSION::On::Set()`).
- Минимальное потребление ресурсов — без использования HAL или стандартной библиотеки C.

=== Недостатки

- Отсутствие надёжного **антидребезга**: простая задержка не гарантирует устойчивую работу при быстром нажатии.
- Избыточная настройка неиспользуемых пинов (`PA5`, `PC8`, `PC9`).
- Прямой доступ к `ODR`/`IDR` через `reinterpret_cast` нарушает стиль, заданный шаблонными регистрами.
- Отсутствие защиты от повторного нажатия во время задержки (может привести к двойному срабатыванию).

== 6. Вывод

Программа успешно демонстрирует базовые принципы работы с периферией STM32 на уровне регистров: включение тактирования, настройка направления GPIO, чтение входов и управление выходами. Реализована простая, но функциональная логика toggle-переключателя. Для промышленного применения рекомендуется улучшить обработку дребезга (например, с помощью таймера) и устранить неиспользуемый код.